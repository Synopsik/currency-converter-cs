@* Steven Baar *@
@* 12/18/26 *@
@* Currency Converter *@
@* This page is used to display conversions for any type that the user filters for *@


@page "/"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@using System.Text
@using System.Text.Json
@using currency_converter_cs.Components.Clients
@using currency_converter_cs.Components.Models
@using currency_converter_cs.Components.Utils
@inject FavoritesService Favorites
@inject ExchangeRateService ExchangeRateService
@inject IJSRuntime Js

<PageTitle>Home</PageTitle>

<!-- JavaScript for handling file downloads -->
<script>
    // Creates a globally accessible JS function
    window.downloadCsv = (filename, content) => {
        // Creates an anchor element in memory
        const element = document.createElement('a');
        // Construct data link from the formatted table
        element.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(content));
        // Download resource through the constructed link instead of navigating to it
        element.setAttribute('download', filename);
        // Force a simulated "click" on our temporary anchor element we created
        document.body.appendChild(element);
        element.click();
        // Free the resource from memory after download has started
        document.body.removeChild(element);
    };
</script>

<h1>Daily Currency Conversion Rates</h1>

@if (_allCurrencies is null || !_allCurrencies.Any())
{
    <p>No results available.</p>
}
else
{
    <!-- UpDated Layout with Labels and Export Button -->
    <div class="filters d-flex align-items-end gap-3 mb-3">

        <!-- FROM Group dropdown -->
        <div>
            <label class="form-label fw-bold mb-1">From</label>
            <select @bind="_selectedFrom" @bind:after="LoadTableData" class="form-select" style="min-width: 100px;">
                @foreach (var currency in _allCurrencies)
                {
                    <option value="@currency">@currency.ToUpper()</option>
                }
            </select>
        </div>

        <!-- TO Group dropdown -->
        <div>
            <label class="form-label fw-bold mb-1">To</label>
            <select @bind="_selectedTo" @bind:after="LoadTableData" class="form-select" style="min-width: 100px;">
                <option value="*">*</option>
                @foreach (var currency in _allCurrencies)
                {
                    <option value="@currency">@currency.ToUpper()</option>
                }
            </select>
        </div>

        <!-- DATE filter -->
        <div>
            <label class="form-label fw-bold mb-1">Date</label>
            <input type="date"
                   class="form-control"
                   style="min-width: 150px;"
                   @bind="_selectedDate"
                   @bind:after="LoadTableData" />
        </div>

        <!-- Export Button -->
        <button class="btn btn-success" @onclick="ExportTable" disabled="@(_tableRows.Count == 0)">
            Export CSV
        </button>

        <!-- Manual Refresh Button -->
        <button class="btn btn-primary" @onclick="LoadTableData">
            Refresh Rates
        </button>
    </div>

    @if (_tableRows.Count == 0)
    {
        <p>Loading data...</p>
    }
    else
    {
        <table class="table table-striped table-bordered align-middle">
            <thead>
                <tr>
                    <th>From</th>
                    <th>To</th>
                    <th>Rate</th>
                    <th>Date</th>
                    <th style="text-align: center;">Favorite</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var row in _tableRows)
                {
                    <tr>
                        <td>@row.From.ToUpper()</td>
                        <td>@row.To.ToUpper()</td>
                        <td>@row.Rate</td>
                        <td>@row.Date</td>
                        <td style="text-align: center;">
                            <button class="btn btn-link p-0 text-decoration-none" style="font-size: 1.2rem;"
                                    @onclick="() => Favorites.AddFavorite(row.From, row.To)">
                                ❤️
                            </button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}


@code {
    private List<string> _allCurrencies;
    private readonly List<ConversionRow> _tableRows = new();

    private string _selectedFrom = "usd";
    private string _selectedTo = "*";
    private DateTime? _selectedDate = DateTime.UtcNow;
    private CancellationTokenSource _cts = new();

    /// <summary>
    /// When the page initializes, get the latest rates for usd.
    /// Using the key "usd", deserialize all the To rates and sort them.
    /// Finally, use the sorted list of rates as our _allCurrencies variable for filtering
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("=== Initializing Home ===");

        // Get the latest response for usd
        var data = await ExchangeRateService.GetRatesAsync("usd");

        if (data != null)
        {
            // Always returns the name of the input currencyCode, "usd"
            var baseCurrency = data.Rates.Keys.First();
            Console.WriteLine($"[INFO] Base currency: {baseCurrency}");
            // Gather the JSON representation of all the rate conversions for our baseCurrency
            var dict = data.Rates[baseCurrency].Deserialize<Dictionary<string, decimal>>();

            if (dict != null)
            {
                // Sort all the To currency in ascending order and store it in a list
                _allCurrencies = dict.Keys.OrderBy(x => x).ToList();
            }
        }
        // Once the data for the filters is loaded, we can begin loading the table data
        await LoadTableData();
    }


    /// <summary>
    /// Attempts to load the current table data while catching and cleaning up any canceled operations
    /// </summary>
    private async Task LoadTableData()
    {
        Console.WriteLine("=== LoadTableData CALLED ===");
        Console.WriteLine($"[INFO] SelectedFrom = {_selectedFrom}, SelectedTo = {_selectedTo}");

        // Triggers when a new task is created to load table data,
        // cancel the old token so it throws current operations
        _cts.Cancel();
        // Then create a new token
        _cts = new CancellationTokenSource();
        var token = _cts.Token;

        try
        {
            // Start the new load table data operation.
            await LoadTableDataInternal(token);
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("[INFO] Previous LoadTableData aborted.");
        }
    }

    /// <summary>
    /// Load the table in the contex of the To currency, From currency, and Date filters
    /// </summary>
    /// <param name="token">Cancellation token reference</param>
    private async Task LoadTableDataInternal(CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // Convert the date filter to a normalized date string
        var date = _selectedDate.ToString();
        var normalizedDate = Formatting.NormalizeDate(date);

        // Clear the current table
        _tableRows.Clear();
        // Use the From currency and the normalized date to query the latest rates
        var data = await ExchangeRateService.GetRatesAsync(_selectedFrom, normalizedDate, token);
        token.ThrowIfCancellationRequested();

        // If no data is found, return immediately and display the issue
        if (data == null)
        {
            Console.WriteLine("GetRatesAsync returned NULL");
            return;
        }

        // If our From currency filter is not in our queried rates, return immediately and display the issue
        if (!data.Rates.TryGetValue(_selectedFrom, out var rateElement))
        {
            Console.WriteLine("SelectedFrom not found in dataset");
            return;
        }

        // Deserialize the RatesResponse Rates property as a Dictionary with string keys and decimal values
        // We can only do this if we have a generic JsonElement in our RatesResponse model
        var dict = JsonSerializer.Deserialize<Dictionary<string, decimal>>(rateElement);

        if (dict == null)
        {
            Console.WriteLine("[Error] Returned list is null");
            return;
        }

        // Display all key value pairs if our To filter is "*"
        if (_selectedTo == "*")
        {
            foreach (var kvp in dict)
            {
                _tableRows.Add(new ConversionRow
                {
                    From = _selectedFrom,
                    To = kvp.Key,
                    Rate = kvp.Value,
                    Date = data.Date
                });
            }
        }
        // Otherwise use our To filter to define which ConversionRow to display
        else if (dict.TryGetValue(_selectedTo, out var rate))
        {
            _tableRows.Add(new ConversionRow
            {
                From = _selectedFrom,
                To = _selectedTo,
                Rate = rate,
                Date = data.Date
            });
        }

        Console.WriteLine($"FINAL ROW COUNT: {_tableRows.Count}");
        // Re-render the display
        StateHasChanged();
    }



    /// <summary>
    /// Formats our current table to CSV and starts the export by invoking our JS function
    /// </summary>
    private async Task ExportTable()
    {
        var fileName = "";

        // Define the filename
        if (_selectedTo == "*")
        {
            // If the table contains all the conversions for a currency
            fileName = $"{_selectedFrom}-{DateTime.Now:yyyy.M.d}.csv";
        }
        else
        {
            // If the table contains a single conversion for a currency
            fileName = $"{_selectedFrom}-to-{_selectedTo}-{DateTime.Now:yyyy.M.d}.csv";
        }

        // Format the current table to CSV
        var csvString = await CsvUtil.FormatTableToCsv(_tableRows);

        // Call our globally accessible JS function "downloadCsv" to trigger the download
        await Js.InvokeVoidAsync("downloadCsv", fileName, csvString);
    }
}